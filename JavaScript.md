<h1>--자바스크립트 문법--</h1>

틈틈히 정리하고 싶은 내용 기록 예정 📚 모던 자바스크립트 Deep Dive 을 주로 공부 기록

### 객체 리터럴 

-객체: 자바스크립트는 객체 기반의 프로그래밍 언어이며, 원시 값을 제외한 함수, 배열, 정규표현식 등은 모두 객체이다 

객체타입의 경우 다양한 타입의 값으로 구성된 자료구조이자 변경 가능한 값이다 
구성) 0개 이상의 프로퍼티 (프로퍼티의 경우 키와 값으로 구성 / 모든 값이 프로퍼티 값이 될 수 있다)  메서드 (프로퍼티 값이 함수일 경우 메서드라고 지칭) 으로 구성된다 


자바스크립트의 객체 생성 방법
<ol>
  <li>객체 리터럴</li>
  <li>Object 생성자 문제</li>
  <li>생성자 함수</li>
  <li>Object.create 메서드</li>
  <li>클래스</li>
</ol>

### 프로퍼티 

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다 / 프로퍼티를 나열할 때는 ,로 구분된다 

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값 / 프로퍼티 값에 접근할 수 있는 식별자 역할을 한다
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 / 

### 메서드 

프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해서 메서드라고 부른다 

```
let circle = {
  radius: 5, 
  
  getDiameter : function () { // 메서드 
    return 2 * this.radius;
   }
};
console.log(circle.getDiameter());
  
```

### 프로퍼티 접근 

접근하는 방법 
> 1. . 접근 연산자를 사용하는 마침표 표기법 
> 2. [] 접근 연산자를 사용하는 대괄효 표기법  / 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다 

```
let person = {
  name: 'lee'
};

console.log(person.name) // lee
console.log(person['name']) // lee 
```

### 프로퍼티 값 조작하기 

- 프로퍼티 값 갱신 : 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값은 갱신이 된다 

```
person.name = 'kim'
console.log(person.name) // kim 
```

- 프로퍼치 동적 생성 : 존재하지 않은 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당 된다 

```
person.age = '20' 
console.log(person.age) // 20
```

- 프로퍼티 삭제 : delete 연산자는 객체의 프로퍼티를 삭제한다 / 만약 존재하지 않은 프로퍼티를 삭제하면 아무런 에러 없이 삭제된다 

```
delete persone.age;
```

### ES6 에서 추가된 객체 리터럴 확장 기능 

객체리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적으로 생성할 수 있다 

```
const prefic = 'prop';
let i = 0;

const obj = {
  [`${prefix}-${++i}`] : i,
  [`${prefix}-${++i}`] : i,
  [`${prefix}-${++i}`] : i
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

<hr> 

#### Event Loop, Main Thread , call back

이벤트 루프 모델에서는 여러 개의 스레드를 사용하는데 그중 메인 스레드에서 자바스크립트 코드가 실행이 된다

❗ 메인 스레드는 하나 이며 한 순간에 한 줄씩만 사용 (file, I/O , network 와 같은 일을 담당하는 워커 스레드는 여러개 있을 수 있음)

- call back : 콜백은 브라우저나 node에 의해 이벤트가 발생하게 되면 메인 스레드에 이를 알려 주기 위하여 callback을 사용한다 

지금 시점 까지 불린 함수들의 stack, 리턴 될때마다 stack에서 함수가 나가게 된다 

Run-to-completion : 이벤트 루프가 다음 콜백을 처리하기 위해서는 현재 콜백 실행이 완전히 끝나야 한다 

- call back queue  : 앞으로 실행할 콜백(함수와 그 인자)들을 쌓아 두는 큐이다 

#### Hosting , Closure

- hosting: 자바스크립트의 경우 변수의 선언과 함수들을 해당 스코프의 맨 위로 끌어올리는 경우를 호스팅이라고 한다 (변수의 경우 초기화 선언 (값할당) 까지 호스팅 되는 것이 아니므로 초기화 하지 않은채 출력하게 되면 undefined가 출력되게 된다)
- closure : function + environment(함수가 접근 할 수 있는 범위) , 함수가 생성 될 때마다 closure가 생성이 된다 

<hr>

### String 객체 

> String 메서드 

: String 객체에는 원본을 직접 변경하는 메서드는 존재하지 않는다 String 객체의 메서드는 언제나 새로운 문자열을 반환한다 즉, 문자열은 변경불가능한 원시값이기 때문에 String 객체도 읽기 전용 객체로 제공된다 


- str.indexof('a') : a가 문자열 str 어느 곳에 위치하는지 인덱스 값을 반환한다 검색에 실패하면 -1을 반환한다 / 두번째 인자로 어디서 부터 탐색을 시작할지도 정할 수 있다 
- 특정 문자열이 존재하는지 확인할 때 : indexOf, includes

- str.search(문자열, 정규표현식 등) : 인수로 전달받은 정규표현식과 매치하는 문자열을 검색하여 일치하는 문자열 인덱스를 반환, 없을 때에는 -1 반환 
- str.startWith(문자열, 문자 등) : 대상문자열이 인수로 전달 받은 문자열로 시작하는지 확인하여 그 결과를 true 또는 false로 반환한다 
- str.endsWidth(문자열 ,문자 등) : 대상문자열이 인수로 전달 받은 문자열로 끝나는지 확인한여 그 결과를 true 또는 false로 반환한다 
- str.charAt(index값) : 인수로 전달받은 숫자값(인덱스값)에 위치한 문자를 반환한다 
- str.substring(1,4) : 첫번째와 두번째로 받은 인자 사이의 값의 문자열을 반환한다 참고로 첫번째 이상 두번째 미만까지 반환한다 만일 두번째 인수를 생략할 경우 마지막 인덱스까지를 범위로 반환한다 
- str.slice(0,5) : substring과 동일한 방식으로 작동한다 단 slice 메서드에는 음수인 인수를 전달 할 수 있다 음수인 인수가 전달되면 가장 뒤에서부터 시작하여 문자열을 잘라내어 반환한다
- str.toUpperCase() : 대상문자열을 모두 대문자화 한다 
- str.toLowerCase() : 대상문자열을 모두 소문자화 한다 
- str.trim() : 대상문자열 앞뒤로 공백이 있는 경우 이를 제거한다 
- str.reapeat(반복하고자하는숫자) : 인수로 전달받은 정수만큼 반복해서 연결한 새로운 문자열을 반환한다 
- str.replace('world', 'what') : 첫번째 인수로 전달받은 문자열이나 정규표현식을 검색해서 두 번째 인수로 전달한 문자열로 치환한 문자열로 반환한다 
- str.split(' ') : 인수로 전달된 문자열 또는 정규표현식을 검색하여 문자열을 분리한 뒤 배열로 반환한다 ''의 경우 문자열을 한글자 한글자 배열로 구성하여 반환한다 ' ' 은 공백을 기준
- str.charCodeAt(인덱스번호) : 인덱스에 해당하는 문자의 아스키코드 값을 반환한다 

<hr>

### 배열 

자바스크립트 배열은 해시테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 느리다 / 특정 요소를 검색하거나 요소를 삽입 삭제하는 경우에는 일반적인 배열보다는 빠른 속도를 기대할 수 있다 

- Array 생성자 함수 : const arr = new Array(10); -> 원소가 empty인 길이가 10인 배열 생성 / 인수로 숫자가 아닌 배열 원소들을 넣을 수 있다 
- Array.of(1,2,3) : 인수로 전달된 숫자들을 원소로 가지는 배열을 반환한다 [1,2,3] 
- Array.from({ length: 2, 0 :'a', 1:'b' });  -> 유사배열 객체 또는 이터러블객체를 인수로 전달받아 배열로 변환하여 반환 / 문자열을 인수로 넣었을 경우 문자열 원소가 하나하나 분리된 배열이 생성된다
- 배열 요소의 추가 : 존재하지 않은 인덱스 값을 사용해 값을 할당하면 새로운 요소가 추가된다
- 배열 요소의 삭제 : delete arr[1] 방식으로 삭제하고자 하는 인덱스를 넣어준다 / 주의점은 이때 배열의 length는 변하지 않는다  length값까지 같이 갱신하고자 한다면 splice를 사용하여야 한다 

> 배열 메서드 

- arr.indexOf(2) : 인수로 전달된 값을 배열 내에서 검색하여 존재하는 경우 인덱스 값을 반환하고 존재하지 않은 경우 -1를 반환한다 
- arr.push(2,3) : 인수로 전달받은 모든 값을 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반한환다  / 원본을 직접 변경한다 / 성능이 좋지 않다 
- arr.pop() : 원본배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다 / 원본을 직접 반환한다 
- arr.unshift(3,4) : 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다 / 원본배열을 직접 변경한다 
- arr.shift() : 원본배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다 / 원본 배열을 직접 변경한다 
- arr.concat(arr2) : 인수로 전달된 배열 또는 원시값들을 원본배열의 마지막요소로 추가한 새로운 배열을 반환한다 / 원본배열을 변경하지 않는다 
- arr.splice(start, deleteCount, items) : start위치부터 deleteCount 만큼 삭제하고 items에 위치한 값들을 새로운 요소로 삭제된 자리에 추가한다 / 원본배열을 변경한다 / 재거된 원소들이 배열행태로 반환된다 / 제거할 개수를 0으로 설정하게 되면 아무런 요소를 제거하지 않고 새로운 요소들을 삽입한다 / 추가할 items들을 지정하지 않으면 삭제만 진행한다 
- arr.slice(start,end) : 원본배열을 변경하지 않고 인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다 / start부터 시작하여(음수인 경우 배열의 끝에서부터를 의미한다) end 직전 값까지 배열을 한다 (생략하는 경우 끝까지 복사가 된다) 
- arr.join('') : 원본 배열의 모든 요소를 문자열로 반환한 후 인수로 전달된 문자열을 기준으로 문자열을 반환한다 
- arr.reverse() : 원본배열의 순서를 반대로 뒤집는다 / 원본배열이 수정된다 
- arr.fill(0,1,3) : 1부터 2까지 0으로 배열을 채운다 / 원본배열이 수정된다 
- arr.includes(문자열,숫자값등) : 배열 내에 인수로 전달된 값이 존재하는지 확인하여 true 또는 false를 반환한다 

> 배열 고차 함수 

- sort()의 특징 
1. 기본적으로 오름차순으로 정렬이 된다 
2. 내림차순으로 정렬을 원할 때에는 sort() -> reverse()를 순서대로 실행한다 
3. 문자열 요소로 이루어진 배열은 앞선 조건에 문제가 없지만 숫자로 이루어진 배열의 경우 유니코드 포인트 순서대로 정렬을 하는 sort()에 의해서 원하는 대로 값이 정렬되지 않을 수 있다
4. 숫자 요소를 비교할때에는 sort메서드에 정렬 순서 정의하는 비교함수를 인수로 전달해야한다 
5.    1)  비교함수는 양수나 음수를 반환해야 한다
      2)  반환값이 0보다 작으면 첫번째값 인수를 우선으로 정렬한다
      3)  반환값이 0보다 크면 두번째값 인수를 우선으로 정렬한다
      4)  반환값이 0 인경우 정렬하지 않는다
      5)  오름차순 정렬 예시 ```arr.sort((a,b) => { if (a > b) { return -1 } else if (a == b) { return 0 } else if (a < b ) {return 1}``` 

- arr.forEach(items => if (items % 2 == 0) {temp.push(items}) : for문을 대체하여 배열안을 순회 할때 사용하는 메서드이다 실행시마다 콜백함수를 실행할 수 있다  / arr.forEach((item,index, arr) => .... ) 인수 순서대로 현재 지칭하는 값, 현재 index 값, 원본 배열이 올 수 있다 / break와 continue 를 사용할 수 없다
- arr.map(item => item ** 2) : 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수를 반복호출한다 그 후 반환값들로 새로운 배열을 반환한다 / 원본배열은 변하지 않는다 / 콜백함수의 인수로 forEach과 같이 요소값, 인덱스, this(배열그자체)를 사용할 수 있다 
- arr.filter(item => item % 2 ) 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수를 반복호출한다 그 후 반환값이 true인 것들만을 모아 새로운 배열을 생성하여 반환한다 / 원본 배열은 변경하지 않는다 / forEach, map과 마찬가지로 콜백함수 인수로 요소, 인덱스값, this를 사용할 수 있다 
- arr.reduce((acc,current, index, arr) => acc + cur , 0 ) : 자신을 호출한 배열으 ㅣ모든 요소를 순회하면서 인수로 전달받은 콜백함수를 호출한다 이때 콜백함수 반환값은 다음 순회시에 콜백함수의 첫번째 인수로 전달되면서 하나의 결과값을 만들어 전달한다/ 콜백함수와 초기값을 인수로 받는다 / 원본배열을 변환하지 않는다
- arr.some(item => item > 10) : 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백함수를 호출한다 이때 콜백함수의 반환값이 단 한번이라도 true라면 true를 반환 모두 false일 경우에만 false를 반환한다 / forEach, map, filter와 마찬가지로 콜백함수 인수로 요소값, 인덱스 값, this를 사용할 수 있다 
- arr.every(item => item > 10) : 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백함수를 호출한다 이때 콜백함수의 반환값이 단 한번이라도 false라면 false를 반환하고 모두 true인 경우에만 true를 반환한다 / some과 마찬가지로 요소값, 인덱스 값, this를 사용할 수 있다 / 단 빈배열의 경우 true를 반환하기 떄문에 주의해야한다 
- arr.find(item => item.id == 2) : 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백함수를 호출한다 콜백함수 반환값들 중 첫번째로 true를 반환한 요소를 반환한다 만약 true가 나오지 않는다면 undefined를 반환한다 / every와 마찬가지로 요소값, 인덱스 값, this를 사용할 수 있다
- arr.findIndex(imte => item.id == 2) : 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백함수를 호출한다 콜백함수 반환값 중 첫번째로 true를 반환한 요소의 index값을 반환한다 만약 true가 나오지 않는다면 -1 를 반환한다 / find와 마찬가지로 요소값, 인덱스 값,this를 사용할 수 있다 
- arr.flatMap(x => x.split('')) : 콜백함수 내에 전달된 문자열 배열 등을 평탄화 하는 작업을 진행한다

<hr>

### 모듈 

#### 모듈의 의미 
모듈 : 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 의미 

> 특징 
> 1. 모듈은 기능을 기준으로 파일 단위로 분리
> 2. 모듈은 자신만의 파일 스코프를 가진다 
> 3. 자신만의 파일 스코프를 가지는 모듈의 자산 (변수, 함수, 객체 등)들은 기본적으로 비공개 상태이다 / 모듈은 애플리케이션과 분리되어 존재
> 4. 모듈은 공개가 필요한 자산에 한정하여 선택적으로 공개를 하는데 이때 export를 사용한다 
> 5. 모듈의 사용자는 공개된 모듈들 중 하나를 선택하기 위해 import를 사용한다 

#### 자바스크립트와 모듈 

자바스크립트 파일을 여러 개의 파일로 분리하여 script 태그로 로드한다 이렇게 하면 분리된 자바스크립트 파일들도 결국 하나의 자바스크립트 파일 내에 있는 것처럼 동작한다 그런데 이렇게 하게 되면 분리된 자바스크립트 파일들 내에서 이름이 중복되는 등의 문제가 있기 때문에 해당 방식으로는 모듈을 구현할 수 없다

이러한 한계들을 벗어나기 위해 자바스크립트에서는 CommonJS 또는 AMD 모듈 로더 라이브러리를 사용한다 

#### 모듈 사용하기 

- export : 변수 또는 함 수 앞에 붙이면 외부 모듈에서 해당 함수 변수에 접근이 가능 
- import : 지시자를 사용하면 위부 모듈의 기능을 가져올 수 있음 

```
//export로 함수 밖으로 빼내기 
export function sayHello(user) {
  console.log(`Hello ,${user} );
}
//import로 다른 곳에서 함수 사용하기 
import {sayHello} from './sayHello.js';

sayHello('JASUN');
```

#### 모듈의 핵심 기능

1. 엄격 모드로 실행이 된다 : 모듈은 항상 use strict로 실행 / 선언되지 않은 변수에 값을 할당하는 등의 코드는 에러를 발생시킴 
2. 모듈 레벨 스코프 : 모듈내부에서 정의한 변수나 함수는 다른 스크립트에서는 접근할 수 없다 / export로 지정한 모듈만 사용이 가능 
3. 단 한번만 평가가 된다 : 동일한 모듈이 여러 곳에서 사용되더라도 모듈은 최초 호출 시 단 한번만 실행이 된다 / 여러가지 모듈이 같은 객체에 대해서 한 모듈이 해당 객체를 수정하게 되면 다른 모듈에서도 객체의 변경사항을 확인을 할 수 있다 
4. import.meta : 현재 모듈에 대한 정보를 제공해준다 
5. this는 undefined : 모듈 최상위 레벨의 this는 undefined이다

#### 모듈이 브라우저에서 사용이 되었을 때 

### 지연실행 

모듈 스크립트는 항상 지연 실행된다 / html 문서가 완전히 준비될 때까지 대기 상태에 있다가 html 문서가 완전히 만들어진 이후에 실행된다 / 스크립트의 상대적 순서는 유지 되므로 문서상의 위쪽의 스크립트 부터 차례대로 실행이 된다 

### 인라인 스크립트의 비동기 처리 

모듈 스크립트에선 async 속성을 인라인 스크립트에도 적용할 수 있다 / async 속성을 적용하게 되면 다른 스크립트나 html이 처리되길 기다리지 않고 바로 실행이 된다 

사용 예시 
```
<script async type="module">
  import {counter} from './analytics.js';
  counter.count();
 </script>
```

해당 특징은 광거노 문서 레벨의 이벤트 리스너, 카운터 같이 어디에도 종속되지 않은 기능을 구현할 때 유용하게 사용할 수 있다


### 외부스크립트 

1. src 속성값이 동일한 외부 스크립트는 한 번만 실행된다 
```
<!--my.js는 한번만 실행이 된다-->
<script type="module" src="my.js"> </script>
<script type="module" src="my.js"> </script>
```
2. 외부사이트와 같이 다른 오리진에서 모듈 스크립트를 불러오면 CORS 헤더가 필요하다 

### 경로가 없는 모듈은 금지 된다 

브라우저 환경에서는 import 는 반드시 상대 혹은 절대 URL 앞에 와야 한다 

<hr> 

## 스프레드 문법 

...은 하나로 뭉쳐져 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다 / 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM컬렉션(NodeList, HTMLCollection), argument와 같이 for.. of 문으로 순회할 수 있는 이터러블에 한정된다 

### 함수 호출문의 인수 목록에서 사용하는 경우 

배열을 펼쳐서 개별적인 값들의 목록으로 만든 후 이를 함수의 인수 목록으로 전달한다 
```
const max = Math.max(...arr); 
```

*Rest 파라미터 : 스프레드 문법과 동일하게 표기를 한다 그렇지만 Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개 변수 이름 앞에 ...을 붙이는 것이다

### 배열 리터럴 내부에서 사용하는 경우 

#### concat 을 대체하기 

2개의 배열을 하나로 합칠때  

1. concat 
```
let arr = [1,2].concat(arr2); 
```
2. 스프레드 문법 
```
const arr = [...[1,2], ...arr2];
```

#### splice 

어떤 배열의 중간에 다른 배열의 요소들을 추가하거나 제거하려면 splice를 사용한다/ 세번째 인수로 배열을 전달하면 배열 전체가 추가 된다 

```
let arr1 = [1,4];
let arr2 = [2,3];

arr1.splice(1,0,arr2); // [1,[2,3],4] 

arr1.splice(1,0,...arr2) // [1,2,3,4]
```

#### 이터러블을 배열로 반환 

```
// 스프레드 사용하지 않았을 때
function sum() {
  let args = Array.prototupe.splice.call(arguments);
  
  return args.reduce(function (pre,cur) {
    return pre + cur;
  },0);
}

// 스프레드 문법을 사용할 때 

function sum() {
  return [...arguments].reduce((pre,cur) => pre+cur , 0 ); 
 } 
console.log(sum(1,2,3)); // 6

```
<hr>

## 함수 

### 함수 생성 시점과 함수 호이스팅 

함수표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. 

함수 선언문도 코드가 한 줄 씩 순차적으로 실행되는 시점인 런타임 이전에 자바사크립트 엔진에 의해 먼저 실행된다  즉, 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 된 상태이다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수 있다 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트 고유의 특징을 "함수 호이스팅"이라고 한다 

### 화살표 함수 

function 키워드 대신 화살표를 사용해 좀 더 간략하게 함수를 선언할 수있다 화살표 함수는 항상 익명 함수로 정의 된다 

특징 
1. 생성자 함수로 사용할 수 없다 
2. 기존 함수와 this 바인딩 방식이 다르다 
3. prototype 프로퍼티가 없다 
4. arguments 객체를 생성하지 않는다 

#### 함수 정의 
```
const multiply = (x,y) => x * y; 
multiply(2,3) 
```
##### 매개변수 
1. 매개 변수가 여러개 일 경우 ()안에 매개변수를 선언한다 
2. 매개변수가 하나일 경우 ()를 생략한다 
3. 매개변수가 없는 경우 ()를 생략할 수 없고 ()를 꼭 표기한다 

##### 함수 몸체 

- 함수 몸체가 하나의 문으로 구성된다면 {}를 생략할 수 있다 
```
const power = x => x ** 2;
```

- 객체 리터릴을 반환하는 경우 객체 리터럴을 ()로 감싸주어야 한다 
```
const create = (id, content) => ({id, content}); 
```
- 함수 몸체가 여러 개의 문으로 구성된다면 {} 를 생략할 수 없다 이때 반환 값이 있다면 명시적으로 return를 활용해 반환해야한다 

#### 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없다 
```
const Foo = () => {..};
new Foo() (x) 사용 불가능 
```
2. 중복된 매개변수 이름을 선언할 수 없다 
3. 화살표 함수는 함수 자체의 this, arguments,super, new.target 바인딩을 가지지 않는다 따라서 화살표 내부에서 해당 사항들을 참조하면 스코프 체인을 통해 상위 스코프의 this,arguments, super, new.target을 참조한다 


### 비동기 프로그래밍 

함수가 호출된 순서대로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨테스트가 실행 컨테스트에 푸시 되기 때문이다
자바스크립트의 경우 하나의 실행 컨텍스트 스택을 갖는다. 한번에 하나의 태스크만을 실행할 수 있는 싱글 스레드 방식으로 동작하기 때문에 2개이상의 함수를 동시에 실행할 수 없다 

#### 동기 처리 방식 
자바스크립트가 단 하나의 실행 컨텍스트를 가지기 때문에 현재 실행중인 테스크가 종료 될 떄까지 다음에 실행될 태스크가 대기하는 방식을 동기처리 라고 한다. 
동기처리방식의 경우 태스크를 순서대로 하니씩 처리하므로 실행 순서가 보장된다는 장점이 있지만 헤당 테스크가 현재 실행중인 태스크가 중단 될때까지 테스크들이 블로킹 된다 

#### 비동기 처리 방식 
동기 처리방식과 다르게 현재 실행중인 태스크가 종료되지 않은 상태라 해도 다음 테스크를 곧바로 실행하는 방식이다 
블로킹이 발생하지 않는다는 장점이 있지만 태스크의 실행 순서가 보장되지 않는 다는 단점이 있다 

#### 자바스크립트에서는 비동기 처리 방식이 어떻게 작동하는 가? 

앞서 말한 것 처럼 자바스크립트의 경우 단 하나의 실행 컨텍스트를 가지기 때문에 두 가지의 함수를 동시에 실행하지 못한다. 하지만 실제로 브라우저를 사용하다 보면 브라우저내의 자바스크립트는 동시에 여러가지 일을 수행한다 (브라우저의 경우 멀티 스레드로 동작한다) 
이는 자바스크립트의 동시성을 지원하는 이벤트 루프 덕이다. 

이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나이다. 

자바스크립트 엔진의 경우 두 가지의 영역으로 나누어진다 
1. 콜 스택 : 함수가 호출 되면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다 / 자바스크립트 엔진의 경우 하나의 콜 스택만을 사용하기 때문에 최상위 실행 컨텍스트(=실행중인 컨텍스트)가 종료되어 제거 되기 까지 다른 함수들이 실행이 되지 않는다 
2.  힙 : 객체가 저장되는 메모리 공간이다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다. / 메모리에 값을 젖아하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 한다 하지만 객체의 경우 크기가 사전에 결정되지 않아 메모리 공간의 크기를 런타임에서 결정(동적할당)해야만한다. 따라서 객체가 저장되는 메모리 공간의 힙은 구조화가 되어 있지 않다 

자바스크립트 엔진의 이러한 특징 때문에 비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 node.js에서 담당한다 

비동기 처리 방식을 위해서 브라우저 환경은 테스트 큐와 이벤트 루프를 활용한다 

1. 테스크 큐 : 비동기함수의 콜백함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
2. 이벤트 루프 : 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지 태스크 큐에 대기 중인 함수가 있는지 확인한다. 만약 콜 스택이 비어 있고 테스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 테스크 큐에 대기중인 함수를 콜 스택으로 이동시킨다. 이떄 콜 스택으로 이동한 함수는 실행된다. 즉 테스크 큐에 일시 보관된 함수들은 비동기 처리방식으로 작동한다. 

